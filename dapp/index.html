
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>SWAP</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%230a0a0a'/><rect x='3' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='5' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='10' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='12' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='4' y='4' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='5' width='10' height='1' fill='%23e8e8e0'/><rect x='2' y='6' width='12' height='3' fill='%23e8e8e0'/><rect x='3' y='9' width='10' height='1' fill='%23e8e8e0'/><rect x='4' y='10' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='10' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='5' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='9' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='2' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='7' y='12' width='2' height='1' fill='%23e8e8e0'/><rect x='11' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='1' y='13' width='2' height='1' fill='%23e8e8e0'/><rect x='13' y='13' width='2' height='1' fill='%23e8e8e0'/></svg>" type="image/svg+xml">
<script src="./ethers.min.js"></script>
<script src="./walletconnect.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: #fff;
  color: #000;
  min-height: 100vh;
  padding: 60px 20px;
  padding-bottom: 20px;
  max-width: 480px;
  margin: 0 auto;
}
h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 40px;
}
.section {
  margin-bottom: 32px;
}
label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
  color: #666;
}
input[type="number"], input[type="text"] {
  width: 100%;
  padding: 12px 0;
  font-size: 24px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid #000;
  outline: none;
  background: transparent;
}
input::placeholder { color: #ccc; }
input:focus { border-bottom-width: 2px; }
button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 12px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: #000;
  color: #fff;
  border: 1px solid #000;
  cursor: pointer;
  margin-right: 8px;
  margin-top: 8px;
  transition: all 0.2s;
}
button:hover { background: #333; }
button:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }
button.secondary {
  background: #fff;
  color: #000;
}
button.secondary:hover { background: #f5f5f5; }

.wallet {
  position: fixed;
  top: max(20px, env(safe-area-inset-top, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  z-index: 100;
}
.wallet button { margin: 0; padding: 8px 16px; text-transform: none; }


.token-select {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  background: #fff;
  border: 1px solid #000;
  padding: 6px 12px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.token-select:hover { background: #f5f5f5; }
.token-icon { width: 24px; height: 24px; display: inline-flex; align-items: center; }
.token-symbol { font-weight: 600; color: #000; }

/* Token input sections */
.token-section {
  margin-bottom: 24px;
}
.token-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}
.amount-input {
  width: 100%;
  background: transparent;
  border: none;
  border-bottom: 1px solid #000;
  font-size: 24px;
  font-weight: 400;
  outline: none;
  color: #000;
  padding: 12px 0;
  font-family: inherit;
}
.amount-input::placeholder { color: #ccc; }
.amount-input:focus { border-bottom-width: 2px; }
.balance {
  font-size: 12px;
  color: #666;
  margin-top: 8px;
}
.token-subactions {
  display: flex;
  justify-content: flex-end;
  margin: 6px 0;
}
.max-btn {
  padding: 4px 10px;
  border: 1px solid #000;
  background: #fff;
  color: #000;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.2s;
  margin: 0;
}
.max-btn:hover { background: #000; color: #fff; }
.max-btn:disabled { opacity: 0.5; cursor: not-allowed; }

/* Swap arrow */
.swap-arrow {
  display: flex;
  justify-content: center;
  margin: 4px 0 16px;
}
.arrow-btn {
  background: #fff;
  border: 1px solid #000;
  padding: 8px;
  cursor: pointer;
  transition: all 0.2s;
  margin: 0;
}
.arrow-btn:hover { transform: rotate(180deg); background: #f5f5f5; }

/* Swap button */
.swap-btn {
  background: #000;
  color: #fff;
  border: 1px solid #000;
  padding: 14px 24px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  cursor: pointer;
  width: 100%;
  margin-top: 16px;
  transition: all 0.2s;
}
.swap-btn:hover:not(:disabled) { background: #333; }
.swap-btn:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }

/* Quote info */
.quote-info {
  padding: 12px;
  background: #f9f9f9;
  margin-top: 16px;
  font-size: 13px;
  color: #000;
  overflow: hidden;
}
.quote-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.quote-row > :nth-child(2) {
  margin-left: auto;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  text-align: right;
}
#routeInfo {
  max-width: 65%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#routeInfo[data-size="sm"] { font-size: 12px; }
#routeInfo[data-size="xs"] { font-size: 11px; }

/* Slippage inline */
.slip-inline {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: text;
}
.slip-unit {
  color: #666;
  font-weight: 600;
  pointer-events: none;
}
.slip-num {
  -webkit-appearance: none;
  appearance: textfield;
  background: transparent;
  border: 0;
  border-bottom: 1px solid rgba(0,0,0,0.25);
  border-radius: 0;
  padding: 2px 0;
  width: 4.5ch;
  min-width: 3.5ch;
  text-align: right;
  font-size: 13px;
  color: #000;
  outline: none;
  transition: border-color 0.15s ease;
}
.slip-num:hover { border-bottom-color: rgba(0,0,0,0.45); }
.slip-num:focus { border-bottom-color: #000; }
.slip-num::-webkit-outer-spin-button,
.slip-num::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.slip-num[type="number"] { -moz-appearance: textfield; }

/* Refresh button & countdown */
.refresh-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  cursor: pointer;
  padding: 2px;
  margin: 0;
  color: #bbb;
  transition: color 0.15s;
  opacity: 0.7;
}
.refresh-btn:hover { color: #888; opacity: 1; }
.refresh-btn svg { display: block; }
.quote-countdown { color: #bbb; font-size: 11px; opacity: 0.7; }

/* Price impact */
.impact-warn { color: #e67e22; }
.impact-danger { color: #e74c3c; font-weight: 600; }

/* All routes collapsible */
.routes-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  color: #666;
  font-size: 12px;
  margin-top: 6px;
}
.routes-toggle:hover { color: #000; }
.routes-list {
  margin-top: 4px;
  font-size: 12px;
  color: #444;
}
.routes-list-item {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
}
.routes-list-item .best-badge {
  background: #000;
  color: #fff;
  font-size: 10px;
  padding: 1px 5px;
  margin-left: 6px;
  letter-spacing: 0.03em;
}

/* Loading spinner */
.loading {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid #666;
  border-top: 2px solid #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  vertical-align: middle;
}
@keyframes spin { 0% { transform: rotate(0); } 100% { transform: rotate(360deg); } }

/* Token modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(4px);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.modal-overlay.active { display: flex; }
body.modal-open { overflow: hidden; }
.modal {
  background: #fff;
  border: 2px solid #000;
  padding: 20px;
  width: 100%;
  max-width: 360px;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.modal-title {
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.modal-close {
  background: none;
  border: none;
  color: #000;
  font-size: 24px;
  cursor: pointer;
  line-height: 1;
  padding: 0;
  margin: 0;
}
.modal-close:hover { opacity: 0.5; }

/* Wallet modal options */
.wallet-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #fff;
  border: 1px solid #000;
  cursor: pointer;
  margin-bottom: 8px;
  transition: all 0.15s;
}
.wallet-option:hover { background: #000; color: #fff; }
.wallet-option-icon { font-size: 1.5rem; }
.wallet-option-name { font-weight: 600; }
.wallet-option.disconnect {
  border-color: #f00;
  color: #f00;
  justify-content: center;
}
.wallet-option.disconnect:hover { background: #f00; color: #fff; }

/* Token list in modal */
.token-list-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  cursor: pointer;
  transition: background 0.2s;
}
.token-list-item:hover { background: #f0f0f0; }
.token-balance { margin-left: auto; font-size: 12px; color: #888; font-variant-numeric: tabular-nums; }

/* Custom token input */
.custom-token-input {
  width: 100%;
  padding: 8px 0;
  border: none;
  border-bottom: 1px solid #000;
  margin-top: 8px;
  font-size: 14px;
  font-family: inherit;
  outline: none;
  background: transparent;
}
.custom-token-input:focus { border-bottom-width: 2px; }

/* Token search & .wei list UI */
.token-search {
  width: 100%;
  padding: 8px 0;
  border: none;
  border-bottom: 1px solid #000;
  font-size: 14px;
  font-family: inherit;
  outline: none;
  background: transparent;
}
.token-search:focus { border-bottom-width: 2px; }
.token-search-status {
  font-size: 11px;
  color: #999;
  margin: 4px 0 8px;
  min-height: 14px;
}
.token-search-status.error { color: #e74c3c; }
.token-group-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #999;
  padding: 8px 12px 4px;
  border-top: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.wei-list-remove {
  background: none;
  border: none;
  color: #999;
  font-size: 14px;
  cursor: pointer;
  padding: 0 4px;
  margin: 0;
  line-height: 1;
}
.wei-list-remove:hover { color: #e74c3c; }

/* Status */
.status {
  font-size: 13px;
  margin-top: 16px;
  padding: 12px;
  background: #f9f9f9;
  display: none;
}
.status.show { display: block; }
.status.error { background: #fff0f0; }
.status.success { background: #f0fff0; }

/* Footer */
.site-footer {
  position: relative;
  text-align: center;
  padding: 40px 20px;
  font-size: 11px;
  opacity: 0.4;
  letter-spacing: 0.5px;
}
.site-footer a {
  color: inherit;
  text-decoration: underline;
}
.site-footer a:hover { opacity: 0.7; }

/* Responsive */
@media (max-width: 700px) {
  body { padding: 80px 16px 20px; }
  .wallet { top: 16px; right: 16px; }
  .wallet button { padding: 10px 14px; font-size: 11px; }
  h1 { margin-bottom: 30px; font-size: 13px; }
  input[type="number"], input[type="text"] { font-size: 20px; padding: 14px 0; }
  .amount-input { font-size: 20px; }
  .swap-btn { padding: 14px 20px; }
  .modal { max-width: 100%; margin: 0 10px; }
}
@media (max-width: 380px) {
  body { padding: 70px 12px 20px; }
  input[type="number"], input[type="text"] { font-size: 18px; }
  .amount-input { font-size: 18px; }
  h1 { font-size: 12px; }
}

/* Info tooltip */
.info-tip {
  position: relative;
  display: inline-flex;
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid #999;
  font-size: 11px;
  font-style: italic;
  font-family: Georgia, serif;
  color: #999;
  cursor: help;
  line-height: 1;
}
.info-icon:hover { border-color: #000; color: #000; }
.info-tooltip {
  display: none;
  position: absolute;
  top: 28px;
  left: 0;
  width: 280px;
  padding: 14px 16px;
  background: #fff;
  border: 1px solid #ddd;
  font-size: 12px;
  font-weight: 400;
  line-height: 1.6;
  letter-spacing: 0;
  text-transform: none;
  color: #333;
  z-index: 200;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}
.info-tip:hover .info-tooltip { display: block; }
body.dark .info-icon { border-color: #555; color: #555; }
body.dark .info-icon:hover { border-color: #e8e8e0; color: #e8e8e0; }
body.dark .info-tooltip { background: #111; border-color: #333; color: #aaa; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }

/* Dark mode toggle */
.dark-toggle {
  position: fixed;
  top: max(22px, env(safe-area-inset-top, 0px));
  left: max(20px, env(safe-area-inset-left, 0px));
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  padding: 6px;
  margin: 0;
  opacity: 0.7;
  transition: all 0.2s;
  z-index: 100;
  line-height: 1;
  color: #000;
  background: #eee;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.dark-toggle:hover { opacity: 1; }

/* Dark mode */
body.dark {
  background: #0a0a0a;
  color: #e8e8e0;
}
body.dark label { color: #777; }
body.dark input[type="number"],
body.dark input[type="text"],
body.dark .amount-input { border-bottom-color: #333; color: #e8e8e0; }
body.dark input::placeholder { color: #444; }
body.dark .token-select { background: #0a0a0a; border-color: #333; }
body.dark .token-select:hover { background: #151515; }
body.dark .token-symbol { color: #e8e8e0; }
body.dark button { background: #e8e8e0; color: #0a0a0a; border-color: #e8e8e0; }
body.dark button:hover { background: #ccc; }
body.dark button:disabled { background: #333; border-color: #333; color: #666; }
body.dark button.secondary { background: #0a0a0a; color: #e8e8e0; border-color: #333; }
body.dark button.secondary:hover { background: #151515; }
body.dark .max-btn { border-color: #333; background: #0a0a0a; color: #e8e8e0; }
body.dark .max-btn:hover { background: #e8e8e0; color: #0a0a0a; }
body.dark .arrow-btn { background: #0a0a0a; border-color: #333; }
body.dark .arrow-btn:hover { background: #151515; }
body.dark .arrow-btn svg { stroke: #e8e8e0; }
body.dark .swap-btn { background: #e8e8e0; color: #0a0a0a; border-color: #e8e8e0; }
body.dark .swap-btn:hover:not(:disabled) { background: #ccc; }
body.dark .swap-btn:disabled { background: #222; border-color: #222; color: #555; }
body.dark .quote-info { background: #111; }
body.dark .quote-info, body.dark .quote-row { color: #ccc; }
body.dark .slip-num { color: #e8e8e0; border-bottom-color: rgba(255,255,255,0.15); }
body.dark .slip-num:hover { border-bottom-color: rgba(255,255,255,0.3); }
body.dark .slip-num:focus { border-bottom-color: #e8e8e0; }
body.dark .slip-unit { color: #777; }
body.dark .balance { color: #666; }
body.dark .routes-toggle { color: #666; }
body.dark .routes-toggle:hover { color: #e8e8e0; }
body.dark .routes-list { color: #999; }
body.dark .routes-list-item .best-badge { background: #e8e8e0; color: #0a0a0a; }
body.dark .loading { border-color: #444; border-top-color: #0a0a0a; }
body.dark .modal-overlay { background: rgba(0,0,0,0.85); }
body.dark .modal { background: #111; border-color: #333; }
body.dark .modal-close { color: #e8e8e0; }
body.dark .wallet-option { background: #111; border-color: #333; color: #e8e8e0; }
body.dark .wallet-option:hover { background: #e8e8e0; color: #0a0a0a; }
body.dark .token-list-item:hover { background: #1a1a1a; }
body.dark .token-balance { color: #666; }
body.dark .custom-token-input,
body.dark .token-search { border-bottom-color: #333; color: #e8e8e0; }
body.dark .token-search-status { color: #666; }
body.dark .token-group-label { color: #555; border-top-color: #222; }
body.dark .wei-list-remove { color: #555; }
body.dark .wei-list-remove:hover { color: #e74c3c; }
body.dark .status { background: #111; color: #ccc; }
body.dark .status.error { background: #1a0000; }
body.dark .status.success { background: #001a00; }
body.dark .site-footer a { color: inherit; }
body.dark a { color: #e8e8e0; }
body.dark .refresh-btn { color: #555; }
body.dark .refresh-btn:hover { color: #999; }
body.dark .quote-countdown { color: #555; }
body.dark .dark-toggle { color: #000; background: #e8e8e0; border-radius: 50%; opacity: 0.7; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; }
body.dark .dark-toggle:hover { opacity: 1; }

@media (max-width: 700px) {
  .dark-toggle { top: 18px; left: 16px; }
}
</style>
</head>
<body>

<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode">&#9789;</button>

<!-- Wallet button (fixed top-right) -->
<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<h1 style="display:flex;align-items:center;gap:8px">Swap <span class="info-tip"><span class="info-icon">i</span><span class="info-tooltip">zRouter is a fully on-chain DEX aggregator. Routes are discovered and optimized by zQuoter directly on the blockchain â€” no off-chain APIs, no solvers, no servers.<br><br>Aggregates Uniswap V2/V3/V4, SushiSwap, Curve, zAMM, and Lido with atomic multi-hop execution, split routing, and per-leg slippage protection.<br><br>Zero protocol fees. No intermediaries. Your trade goes directly from your wallet to the liquidity pools.</span></span></h1>

<!-- From token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">From</label>
    <div class="token-select" onclick="openTokenModal('from')">
      <span id="fromTokenIcon" class="token-icon"></span>
      <span id="fromTokenSymbol" class="token-symbol">ETH</span>
    </div>
  </div>
  <div class="token-subactions">
    <button class="max-btn" type="button" onclick="setMaxFromBalance()">MAX</button>
  </div>
  <input type="number" id="fromAmount" class="amount-input" placeholder="0.0" step="any">
  <div id="fromBalance" class="balance">Balance: --</div>
</div>

<!-- Swap direction arrow -->
<div class="swap-arrow">
  <button class="arrow-btn" onclick="swapTokens()">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#000" stroke-width="2"><path d="M7 10L12 15L17 10"/></svg>
  </button>
</div>

<!-- To token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">To</label>
    <div class="token-select" onclick="openTokenModal('to')">
      <span id="toTokenIcon" class="token-icon"></span>
      <span id="toTokenSymbol" class="token-symbol">USDC</span>
    </div>
  </div>
  <input type="number" id="toAmount" class="amount-input" placeholder="0.0" readonly>
  <div id="toBalance" class="balance">Balance: --</div>
</div>

<!-- Quote info -->
<div id="quoteInfo" class="quote-info" style="display:none">
  <div class="quote-row">
    <span>Route:</span><span id="routeInfo">--</span>
  </div>
  <div class="quote-row">
    <span>Impact:</span><span id="impactInfo">--</span>
  </div>
  <div class="quote-row">
    <span>Slippage:</span>
    <span class="slip-inline">
      <input id="slippagePct" class="slip-num" type="number" inputmode="decimal" min="0" max="20" step="0.1" value="0.5" aria-label="Slippage (%)">
      <span class="slip-unit">%</span>
    </span>
  </div>
  <div class="quote-row">
    <span class="quote-countdown" id="quoteCountdown"></span>
    <span>
      <button class="refresh-btn" onclick="manualRefresh()" title="Refresh quote">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
      </button>
    </span>
  </div>
  <div id="allRoutesWrap" style="display:none">
    <div class="routes-toggle" onclick="toggleAllRoutes()">
      <span class="chevron" id="routesChevron" style="font-size:9px">&#9654;</span>
      <span>All routes</span>
    </div>
    <div id="allRoutesList" class="routes-list" style="display:none"></div>
  </div>
</div>

<!-- Receiver (optional) -->
<div style="margin-top:12px">
  <div style="display:flex;align-items:center;gap:6px;cursor:pointer;user-select:none" onclick="const w=document.getElementById('receiverWrap');const open=w.style.display!=='none';w.style.display=open?'none':'block';this.querySelector('.chevron').textContent=open?'\u25B6':'\u25BC'">
    <span class="chevron" style="font-size:9px;color:#666">&#9654;</span>
    <label style="margin:0;cursor:pointer;pointer-events:none">Receiver</label>
  </div>
  <div id="receiverWrap" style="display:none;margin-top:8px">
    <input type="text" id="receiverAddress" placeholder="0x... (defaults to connected wallet)" style="font-size:14px;padding:10px 0">
  </div>
</div>

<!-- Swap button -->
<button id="swapBtn" class="swap-btn" disabled>Connect Wallet</button>

<!-- Status -->
<div id="status" class="status"></div>

<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<!-- Token Modal -->
<div class="modal-overlay" id="tokenModal" onclick="if(event.target===this)closeTokenModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Select Token</div>
      <button class="modal-close" onclick="closeTokenModal()">&times;</button>
    </div>
    <input type="text" id="tokenSearchInput" class="token-search" placeholder="Search or enter name.wei" autocomplete="off">
    <div id="weiListStatus" class="token-search-status"></div>
    <div id="tokenList" style="max-height:280px;overflow-y:auto"></div>
    <input type="text" id="customTokenAddress" class="custom-token-input" placeholder="Enter token address">
    <button style="margin-top:12px;width:100%" onclick="addCustomToken()">Add Custom Token</button>
  </div>
</div>

<!-- Footer web ring -->
<div class="site-footer">
  <a href="https://wei.domains" target="_blank" rel="noopener">Domains</a> Â· <a href="https://dao.wei.is" target="_blank" rel="noopener">DAO</a> Â· built by <a href="https://dao.wei.is" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg>zOrg</a> Â· <a href="https://zamm.finance" target="_blank" rel="noopener">zAMM</a>
</div>

<script>
// ---- Dark mode ----
function toggleDark() {
  const on = document.body.classList.toggle('dark');
  document.querySelector('.dark-toggle').textContent = on ? '\u2600' : '\u263D';
  localStorage.setItem('dark', on ? '1' : '0');
}
(function() {
  const pref = localStorage.getItem('dark');
  const dark = pref === '1' || (pref === null && window.matchMedia('(prefers-color-scheme: dark)').matches);
  if (dark) { document.body.classList.add('dark'); document.querySelector('.dark-toggle').textContent = '\u2600'; }
})();

// ---- Constants ----
const CHAIN_ID = 1;
const ZQUOTER_ADDRESS = "0x9f373A73ED229C9D133A189c095E2fFb7B77703E";
const ZROUTER_ADDRESS = "0x0000000000001C3a3Aa8FDfca4f5c0c94583aC46";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const USDT_ADDRESS = "0xdAC17F958D2ee523a2206206994597C13D831ec7";
const WBTC_ADDRESS = "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599";
const WSTETH_ADDRESS = "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0";
const RETH_ADDRESS = "0xae78736Cd615f374D3085123A210448E74Fc6393";
const DAI_ADDRESS = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
const PNKSTR_ADDRESS = "0xc50673EDb3A7b94E8CAD8a7d4E0cD68864E33eDF";
const PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const WEINS_ADDRESS = "0x0000000000696760E15f265e828DB644A0c242EB";
const V4_ROUTER_ADDRESS = "0x00000000000044a361Ae3cAc094c9D1b14Eece97";
const PNKSTR_HOOK_ADDRESS = "0xfAaad5B731F52cDc9746F2414c823eca9B06E844";
const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11";
const WEINS_ABI = ["function computeId(string) pure returns (uint256)", "function text(uint256,string) view returns (string)", "function contenthash(uint256) view returns (bytes)", "function reverseResolve(address) view returns (string)"];
const IPFS_GATEWAYS = ["https://content.wrappr.wtf/ipfs/", "https://dweb.link/ipfs/"];

// ---- DOM helpers ----
const $ = id => document.getElementById(id);

function escapeHtml(str) {
  str = String(str ?? '');
  return str.replace(/[&<>"']/g, c => ({
    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
  }[c]));
}

function setText(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (el.textContent !== s) el.textContent = s;
}
let _htmlCache = new WeakMap();
function setHTML(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (_htmlCache.get(el) === s) return;
  el.innerHTML = s;
  _htmlCache.set(el, s);
}
function setShown(id, shown) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  const want = shown ? '' : 'none';
  if (el.style.display !== want) el.style.display = want;
}
function setDisabled(btn, disabled) {
  const el = typeof btn === 'string' ? $(btn) : btn;
  if (!el) return;
  if (!!el.disabled !== !!disabled) el.disabled = !!disabled;
}
function escText(s) {
  return String(s).replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
}
function escAttr(s) {
  return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
function debounce(fn, wait) {
  let t;
  return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), wait); };
}

// ---- Wallet state ----
let provider = null;
let signer = null;
let connectedAddress = null;
let connectedWalletProvider = null;
let walletConnectProvider = null;
let isConnecting = false;
let walletEventHandlers = null;
let isWalletConnect = false;
let wcDeepLink = null;

const eip6963Providers = new Map();

window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) {
      eip6963Providers.set(info.uuid, { info, provider });
    }
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

// ---- Wallet helpers ----
function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) {
      if (checkFn(p)) return p;
    }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();

  // 1. EIP-6963 providers first
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({
        key: `eip6963_${uuid}`,
        name: name,
        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
        getProvider: () => provider
      });
      seenNames.add(name.toLowerCase());
    }
  }

  // 2. Check window.ethereum.providers array
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) {
        detected.push({ key: `provider_${i}`, name, icon: 'ðŸ”—', getProvider: () => p });
        seenNames.add(name.toLowerCase());
      }
    }
  }

  // 3. Legacy WALLET_CONFIG detection
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try {
      if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) {
        detected.push({ key, ...config });
        seenNames.add(config.name.toLowerCase());
      }
    } catch (e) {}
  }

  // 4. Fallback: if nothing detected but window.ethereum exists
  if (detected.length === 0 && window.ethereum) {
    detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
  }

  // 5. WalletConnect
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) {
    detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±' });
  }

  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';

  window.dispatchEvent(new Event('eip6963:requestProvider'));

  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    const hasBrowserWallet = wallets.some(w => w.key !== 'walletconnect');
    if (!hasBrowserWallet && attempt < 2) {
      setTimeout(() => doDetect(attempt + 1), 250);
    } else {
      renderWalletModal(wallets);
    }
  };

  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');

  if (connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `
      <div style="padding: 12px; border: 1px solid #000; margin-bottom: 12px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Connected</div>
        ${showName ? `<div style="font-size: 16px; margin-bottom: 4px;">${escapeHtml(displayName)}</div>` : ''}
        <div style="font-size: 12px; word-break: break-all; opacity: 0.6;">${escapeHtml(connectedAddress)}</div>
      </div>
      <div class="wallet-option disconnect" onclick="disconnectWallet()">
        <span class="wallet-option-name">Disconnect</span>
      </div>
    `;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `
      <div class="wallet-option" data-wallet-key="${escAttr(w.key)}">
        <span class="wallet-option-icon">${w.icon}</span>
        <span class="wallet-option-name">${escapeHtml(w.name)}</span>
      </div>
    `).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => {
      el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey));
    });
  }
}

function closeWalletModal() {
  $('walletModal').classList.remove('active');
  document.body.classList.remove('modal-open');
}

function toggleWallet() {
  showWalletModal();
}

// ---- WalletConnect transaction helper ----
async function wcTransaction(txPromise, message = 'Confirm in your wallet app') {
  if (!isWalletConnect) return txPromise;

  const notif = document.createElement('div');
  notif.id = 'wcNotif';
  notif.innerHTML = `
    <div style="position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:16px;text-align:center;z-index:10000;font-size:14px;">
      <div style="margin-bottom:8px;">ðŸ“± ${escapeHtml(message)}</div>
      <div style="font-size:12px;opacity:0.7;">Open your wallet app to approve the transaction</div>
      ${wcDeepLink && /^https?:\/\//i.test(wcDeepLink) ? `<a href="${escAttr(wcDeepLink)}" style="display:inline-block;margin-top:8px;padding:8px 16px;background:#fff;color:#000;border-radius:4px;text-decoration:none;">Open Wallet</a>` : ''}
    </div>
  `;
  document.body.appendChild(notif);

  try {
    const result = await txPromise;
    return result;
  } finally {
    notif.remove();
  }
}

// ---- waitForTx - robust tx confirmation ----
async function waitForTx(tx, timeoutMs = 90000) {
  const txHash = tx.hash;

  async function pollReceipt(maxAttempts = 45) {
    const p = quoteRPC ? await quoteRPC.call(rpc => rpc) : provider;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const receipt = await p.getTransactionReceipt(txHash);
        if (receipt) {
          if (receipt.status === 0) throw new Error('Transaction reverted');
          return receipt;
        }
      } catch (rpcErr) {
        if (i === maxAttempts - 1) throw rpcErr;
      }
      await new Promise(r => setTimeout(r, 2000));
    }
    return null;
  }

  // For WalletConnect, always use polling
  if (isWalletConnect) {
    const receipt = await pollReceipt();
    if (receipt) return receipt;
    throw new Error('Transaction confirmation timeout');
  }

  // Race tx.wait() against timeout
  let receipt = null;
  let waitError = null;

  try {
    receipt = await Promise.race([
      tx.wait(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeoutMs))
    ]);
  } catch (e) {
    waitError = e;
    const msg = (e.message || '').toLowerCase();
    const shouldPoll = msg.includes('timeout') ||
                       msg.includes('index') ||
                       msg.includes('invalid_argument') ||
                       msg.includes('invalid argument') ||
                       msg.includes('could not coalesce') ||
                       msg.includes('missing response');

    if (shouldPoll && txHash) {
      receipt = await pollReceipt();
    }
  }

  if (receipt) return receipt;
  throw waitError || new Error('Transaction confirmation timeout');
}

// ---- Connect with wallet ----
async function connectWithWallet(walletKey) {
  if (isConnecting) return;
  isConnecting = true;

  try {
    closeWalletModal();
    let walletProvider;

    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;

      if (!WCProvider?.init) throw new Error('WalletConnect not available');

      if (walletConnectProvider) {
        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
        walletConnectProvider = null;
      }

      walletConnectProvider = await WCProvider.init({
        projectId: '1e8390ef1c1d8a185e035912a1409749',
        chains: [1],
        showQrModal: true,
        rpcMap: { 1: 'https://1rpc.io/eth' },
        metadata: {
          name: 'ETH Swap by zAMM',
          description: 'Onchain DEX aggregator',
          url: window.location.origin,
          icons: []
        }
      });

      walletConnectProvider.on('display_uri', (uri) => {
        try {
          const session = walletConnectProvider.session;
          const peerMeta = session?.peer?.metadata;
          if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
          else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
        } catch (e) {}
      });

      await walletConnectProvider.enable();
      walletProvider = walletConnectProvider;
      isWalletConnect = true;

      try {
        const session = walletConnectProvider.session;
        const peerMeta = session?.peer?.metadata;
        if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
        else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
      } catch (e) {}
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) {
        const savedName = localStorage.getItem('zswap_wallet_name')?.toLowerCase();
        if (savedName) {
          for (const [, { info, provider }] of eip6963Providers) {
            if (info?.name?.toLowerCase() === savedName) {
              walletProvider = provider;
              break;
            }
          }
        }
      }
      isWalletConnect = false;
      wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      isWalletConnect = false;
      wcDeepLink = null;
    }

    if (!walletProvider) throw new Error('Wallet not found');

    if (walletKey !== 'walletconnect') {
      await walletProvider.request({ method: 'eth_requestAccounts' });
    }

    // Check/switch chain
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try {
        await walletProvider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x1' }]
        });
        const newChainId = await walletProvider.request({ method: 'eth_chainId' });
        if (BigInt(newChainId) !== 1n) throw new Error('Chain switch failed');
      } catch (switchErr) {
        showStatus('Please switch to Ethereum Mainnet', 'error');
        if (walletKey === 'walletconnect') {
          try { walletConnectProvider?.disconnect(); } catch (e) {}
          walletConnectProvider = null;
        }
        isWalletConnect = false;
        wcDeepLink = null;
        return;
      }
    }

    // Initialize globals
    provider = new ethers.BrowserProvider(walletProvider);
    signer = await provider.getSigner();
    connectedAddress = await signer.getAddress();
    connectedWalletProvider = walletProvider;
    updateWalletDisplay();

    // Store handlers for cleanup
    walletEventHandlers = {
      accountsChanged: () => window.location.reload(),
      chainChanged: () => window.location.reload()
    };
    walletProvider.on('accountsChanged', walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', walletEventHandlers.chainChanged);

    try {
      localStorage.setItem('zswap_wallet', walletKey);
      if (walletKey.startsWith('eip6963_')) {
        const uuid = walletKey.replace('eip6963_', '');
        const name = eip6963Providers.get(uuid)?.info?.name;
        if (name) localStorage.setItem('zswap_wallet_name', name);
      }
    } catch (e) {}

    // Clear caches (provider changed)
    _erc20Read.clear();
    _balanceCache.clear();
    _allowCache.clear();

    // Update swap UI
    setText('swapBtn', 'Enter an amount');
    setDisabled('swapBtn', true);
    updateBalances();
    updateWcBanner();

    const preAmt = $('fromAmount')?.value?.trim();
    if (preAmt) handleAmountChange();

  } catch (error) {
    handleError(error);
  } finally {
    isConnecting = false;
  }
}

function updateWcBanner() {
  const existing = $('wcBanner');
  if (existing) existing.remove();

  if (isWalletConnect && connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = `
      <span>ðŸ“± Connected via WalletConnect</span>
      <button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px;">Disconnect</button>
    `;
    document.body.prepend(banner);
    document.body.style.paddingTop = '44px';
  } else {
    document.body.style.paddingTop = '';
  }
}

function updateWalletDisplay() {
  if (!connectedAddress) {
    $('walletBtn').textContent = 'connect';
    updateWcBanner();
    return;
  }
  $('walletBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
  updateWcBanner();
  // Resolve .wei name in background
  quoteRPC.call(async (rpc) => {
    const ns = new ethers.Contract(WEINS_ADDRESS, WEINS_ABI, rpc);
    const name = await ns.reverseResolve(connectedAddress);
    if (name && connectedAddress) $('walletBtn').textContent = name.toLowerCase();
  }).catch(() => {});
}

function disconnectWallet() {
  if (connectedWalletProvider && walletEventHandlers) {
    try {
      connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
      connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
    } catch (e) {}
  }
  walletEventHandlers = null;

  if (walletConnectProvider) {
    try { walletConnectProvider.disconnect(); } catch (e) {}
    walletConnectProvider = null;
  }
  provider = null;
  signer = null;
  connectedAddress = null;
  connectedWalletProvider = null;
  isWalletConnect = false;
  wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  closeWalletModal();
  try { localStorage.removeItem('zswap_wallet'); localStorage.removeItem('zswap_wallet_name'); } catch (e) {}

  // Reset swap UI
  setText('swapBtn', 'Connect Wallet');
  setDisabled('swapBtn', false);
  setText('fromBalance', 'Balance: --');
  setText('toBalance', 'Balance: --');
  setShown('quoteInfo', false);
  stopQuoteRefresh();
  $('toAmount').value = '';
  _erc20Read.clear();
  _balanceCache.clear();
  _allowCache.clear();
}

function showStatus(msg, type) {
  const el = $('status');
  if (!el) return;
  el.textContent = msg;
  el.className = 'status show' + (type ? ' ' + type : '');
  setTimeout(() => { el.className = 'status'; }, 5000);
}

function handleError(e) {
  const msg = (e.message || e.reason || String(e)).toLowerCase();
  if (msg.includes('user rejected') || msg.includes('user denied') || msg.includes('user cancelled')) return;
  showStatus(e.message || 'An error occurred', 'error');
}

// ---- Token data ----
let currentModal = null;
const tokens = {
  ETH: { address: ZERO_ADDRESS, symbol: "ETH", decimals: 18 },
  USDC: { address: USDC_ADDRESS, symbol: "USDC", decimals: 6 },
  USDT: { address: USDT_ADDRESS, symbol: "USDT", decimals: 6 },
  DAI: { address: DAI_ADDRESS, symbol: "DAI", decimals: 18 },
  WBTC: { address: WBTC_ADDRESS, symbol: "WBTC", decimals: 8 },
  wstETH: { address: WSTETH_ADDRESS, symbol: "wstETH", decimals: 18 },
  rETH: { address: RETH_ADDRESS, symbol: "rETH", decimals: 18 },
  PNKSTR: { address: PNKSTR_ADDRESS, symbol: "PNKSTR", decimals: 18 },
};

// Load custom tokens from localStorage
try {
  const saved = JSON.parse(localStorage.getItem('zswap_custom_tokens') || '[]');
  for (const t of saved) {
    if (t.address && t.symbol && t.decimals != null && !tokens[t.symbol]) {
      tokens[t.symbol] = { address: t.address, symbol: t.symbol, decimals: t.decimals };
    }
  }
} catch (_) {}

function saveCustomTokens() {
  try {
    const builtIn = new Set([ZERO_ADDRESS, USDC_ADDRESS, USDT_ADDRESS, WBTC_ADDRESS, WSTETH_ADDRESS, RETH_ADDRESS, DAI_ADDRESS, PNKSTR_ADDRESS].map(a => a.toLowerCase()));
    const custom = Object.values(tokens).filter(t => !builtIn.has(t.address.toLowerCase()) && !weiListTokenSource.has(t.symbol));
    localStorage.setItem('zswap_custom_tokens', JSON.stringify(custom));
  } catch (_) {}
}

// ---- .wei token list state ----
const weiLists = new Map();       // name â†’ { tokens: [...], loadedAt }
const weiListTokenSource = new Map(); // symbol â†’ listName

function saveWeiLists() {
  try {
    const obj = {};
    for (const [name, data] of weiLists) obj[name] = data;
    localStorage.setItem('zswap_wei_lists', JSON.stringify(obj));
  } catch (_) {}
}

function loadWeiLists() {
  try {
    const raw = JSON.parse(localStorage.getItem('zswap_wei_lists') || '{}');
    for (const [name, data] of Object.entries(raw)) {
      if (data && Array.isArray(data.tokens)) {
        weiLists.set(name, data);
        mergeWeiListTokens(name, data.tokens);
      }
    }
  } catch (_) {}
}

function validateTokenList(rawArray) {
  if (!Array.isArray(rawArray)) return [];
  const seen = new Set();
  const result = [];
  for (const entry of rawArray) {
    if (!entry || typeof entry !== 'object') continue;
    const { address, symbol, decimals } = entry;
    if (!address || !symbol || decimals == null) continue;
    if (!ethers.isAddress(address)) continue;
    const checksummed = ethers.getAddress(address);
    if (checksummed === ZERO_ADDRESS) continue;
    const addrLower = checksummed.toLowerCase();
    if (seen.has(addrLower)) continue;
    const sym = String(symbol).trim();
    if (!sym || sym.length > 24 || !/^[A-Za-z0-9.]+$/.test(sym)) continue;
    const dec = Number(decimals);
    if (!Number.isInteger(dec) || dec < 0 || dec > 36) continue;
    seen.add(addrLower);
    const item = { address: checksummed, symbol: sym, decimals: dec };
    if (entry.icon && typeof entry.icon === 'string') {
      const url = entry.icon.trim();
      if (url.startsWith('https://') || url.startsWith('data:image/')) item.icon = url;
    }
    result.push(item);
  }
  return result;
}

function mergeWeiListTokens(listName, validated) {
  const builtInAddrs = new Set([ZERO_ADDRESS, USDC_ADDRESS, USDT_ADDRESS, WBTC_ADDRESS, WSTETH_ADDRESS, RETH_ADDRESS, DAI_ADDRESS, PNKSTR_ADDRESS].map(a => a.toLowerCase()));
  for (const t of validated) {
    if (builtInAddrs.has(t.address.toLowerCase())) continue;
    let sym = t.symbol;
    // Handle symbol collision with different address
    if (tokens[sym] && tokens[sym].address.toLowerCase() !== t.address.toLowerCase()) {
      sym = sym + '.' + listName.replace(/\.wei$/, '');
    }
    if (!tokens[sym]) {
      tokens[sym] = { address: t.address, symbol: sym, decimals: t.decimals };
      if (t.icon) tokens[sym].icon = t.icon;
    }
    weiListTokenSource.set(sym, listName);
  }
}

// ---- ENSIP-7 contenthash â†’ IPFS CID decoder ----
const BASE32_ALPHA = 'abcdefghijklmnopqrstuvwxyz234567';
function bytesToBase32(bytes) {
  let bits = 0, value = 0, out = '';
  for (const b of bytes) {
    value = (value << 8) | b;
    bits += 8;
    while (bits >= 5) { bits -= 5; out += BASE32_ALPHA[(value >> bits) & 31]; }
  }
  if (bits > 0) out += BASE32_ALPHA[(value << (5 - bits)) & 31];
  return out;
}

function decodeContenthash(hex) {
  try {
    const bytes = ethers.getBytes(hex);
    if (bytes.length < 3) return null;
    let proto = 0, shift = 0, offset = 0;
    for (; offset < bytes.length; offset++) {
      proto |= (bytes[offset] & 0x7f) << shift;
      shift += 7;
      if (!(bytes[offset] & 0x80)) { offset++; break; }
    }
    if (proto !== 0xe3) return null; // IPFS only
    const cidBytes = bytes.slice(offset);
    if (cidBytes[0] === 0x01) return 'b' + bytesToBase32(cidBytes); // CIDv1
    return null;
  } catch { return null; }
}

async function fetchIPFS(cid) {
  let lastErr;
  for (const gw of IPFS_GATEWAYS) {
    try {
      const resp = await fetch(gw + cid);
      if (!resp.ok) throw new Error(resp.status);
      return await resp.text();
    } catch (e) { lastErr = e; }
  }
  throw new Error('All IPFS gateways failed: ' + lastErr?.message);
}

let _weiResolveSeq = 0;

async function resolveWeiList(nameInput) {
  let name = nameInput.toLowerCase().trim();
  if (name.endsWith('.wei')) name = name.slice(0, -4);
  if (!name) return;
  const fullName = name + '.wei';

  if (weiLists.has(fullName)) {
    setHTML('weiListStatus', escText(fullName) + ' already loaded');
    return;
  }

  const seq = ++_weiResolveSeq;
  const statusEl = $('weiListStatus');
  statusEl.className = 'token-search-status';
  statusEl.textContent = 'Loading ' + fullName + '...';

  try {
    // Read both contenthash and text record in parallel
    const { ch, txt } = await quoteRPC.call(async (rpc) => {
      const ns = new ethers.Contract(WEINS_ADDRESS, WEINS_ABI, rpc);
      const tokenId = await ns.computeId(fullName);
      const [ch, txt] = await Promise.all([
        ns.contenthash(tokenId).catch(() => '0x'),
        ns.text(tokenId, 'tokens').catch(() => ''),
      ]);
      return { ch, txt };
    });

    if (seq !== _weiResolveSeq) return;

    let raw = null;

    // Try contenthash first (IPFS)
    if (ch && ch !== '0x' && ch.length > 2) {
      const cid = decodeContenthash(ch);
      if (cid) {
        statusEl.textContent = 'Fetching from IPFS...';
        raw = await fetchIPFS(cid);
        if (seq !== _weiResolveSeq) return;
      }
    }

    // Fall back to text record
    if (!raw || !raw.trim()) {
      raw = txt;
    }

    if (!raw || !raw.trim()) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No token list found on ' + fullName;
      return;
    }

    let parsed;
    try { parsed = JSON.parse(raw); } catch (e) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'Invalid JSON from ' + fullName;
      return;
    }

    const validated = validateTokenList(parsed);
    if (validated.length === 0) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No valid tokens in ' + fullName;
      return;
    }

    weiLists.set(fullName, { tokens: validated, loadedAt: Date.now() });
    mergeWeiListTokens(fullName, validated);
    saveWeiLists();
    statusEl.className = 'token-search-status';
    statusEl.textContent = 'Loaded ' + validated.length + ' tokens from ' + fullName;

    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    if (seq !== _weiResolveSeq) return;
    statusEl.className = 'token-search-status error';
    statusEl.textContent = 'Failed to resolve ' + fullName;
    console.error('.wei resolve error:', e);
  }
}

function removeWeiList(listName) {
  const entry = weiLists.get(listName);
  if (!entry) return;
  // Collect symbols to remove (avoid mutating map during iteration)
  const toRemove = [];
  for (const [sym, src] of weiListTokenSource) {
    if (src !== listName) continue;
    // Don't remove if currently selected
    if (sym === fromToken || sym === toToken) continue;
    toRemove.push(sym);
  }
  for (const sym of toRemove) {
    delete tokens[sym];
    weiListTokenSource.delete(sym);
  }
  weiLists.delete(listName);
  saveWeiLists();
}

function renderTokenList(filter) {
  const list = $('tokenList');
  if (!list) return;
  list.textContent = '';
  const frag = document.createDocumentFragment();
  const q = (filter || '').toLowerCase().trim();

  const builtInAddrs = new Set([ZERO_ADDRESS, USDC_ADDRESS, USDT_ADDRESS, WBTC_ADDRESS, WSTETH_ADDRESS, RETH_ADDRESS, DAI_ADDRESS, PNKSTR_ADDRESS].map(a => a.toLowerCase()));

  function matchesFilter(sym, addr) {
    if (!q) return true;
    return sym.toLowerCase().includes(q) || addr.toLowerCase().includes(q);
  }

  function makeRow(symbol) {
    const t = tokens[symbol];
    const row = document.createElement('div');
    row.className = 'token-list-item';
    row.setAttribute('data-symbol', symbol);
    const iconSpan = document.createElement('span');
    iconSpan.className = 'token-icon';
    iconSpan.innerHTML = iconForSymbol(symbol);
    const nameSpan = document.createElement('span');
    nameSpan.className = 'token-symbol';
    nameSpan.textContent = symbol;
    const balSpan = document.createElement('span');
    balSpan.className = 'token-balance';
    if (connectedAddress && t) {
      const cached = getCachedBalance(t.address);
      if (cached != null && cached > 0n) {
        const formatted = t.address === ZERO_ADDRESS
          ? ethers.formatEther(cached) : ethers.formatUnits(cached, t.decimals);
        balSpan.textContent = fmt(formatted);
      }
    }
    row.append(iconSpan, nameSpan, balSpan);
    return row;
  }

  // Built-in tokens
  let hasAny = false;
  for (const sym of Object.keys(tokens)) {
    if (!builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Per-.wei-list groups
  for (const [listName] of weiLists) {
    const listTokens = [];
    for (const [sym, src] of weiListTokenSource) {
      if (src !== listName) continue;
      if (!tokens[sym]) continue;
      if (!matchesFilter(sym, tokens[sym].address)) continue;
      listTokens.push(sym);
    }
    if (listTokens.length === 0) continue;
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.innerHTML = escText(listName) + ' <button class="wei-list-remove" data-list="' + escAttr(listName) + '" title="Remove list">&times;</button>';
    frag.appendChild(label);
    for (const sym of listTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Custom tokens (not built-in, not from .wei lists)
  const customTokens = [];
  for (const sym of Object.keys(tokens)) {
    if (builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (weiListTokenSource.has(sym)) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    customTokens.push(sym);
  }
  if (customTokens.length > 0) {
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.textContent = 'Custom';
    frag.appendChild(label);
    for (const sym of customTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  if (!hasAny) {
    const empty = document.createElement('div');
    empty.style.cssText = 'padding:16px 12px;color:#999;font-size:13px;text-align:center';
    empty.textContent = q ? 'No tokens match "' + q + '"' : 'No tokens';
    frag.appendChild(empty);
  }

  // Suggestion for token-list.wei
  if (!q && weiLists.size === 0) {
    const suggest = document.createElement('div');
    suggest.style.cssText = 'padding:6px 12px;font-size:11px;color:#999';
    suggest.innerHTML = 'Try loading <span id="weiSuggestLink" style="color:inherit;cursor:pointer;text-decoration:underline">token-list.wei</span>';
    frag.appendChild(suggest);
  }

  list.appendChild(frag);
}

let _weiDebounceTimer = null;

function initTokenSearch() {
  const input = $('tokenSearchInput');
  if (!input) return;

  input.addEventListener('input', () => {
    const val = input.value.trim();
    renderTokenList(val);
    clearTimeout(_weiDebounceTimer);
    if (val.endsWith('.wei') && val.length > 4) {
      _weiDebounceTimer = setTimeout(() => resolveWeiList(val), 800);
    }
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const val = input.value.trim();
      if (val.endsWith('.wei') && val.length > 4) {
        clearTimeout(_weiDebounceTimer);
        resolveWeiList(val);
      }
    }
  });

  // Delegate click on suggestion link
  $('tokenList').addEventListener('click', (e) => {
    if (e.target.id === 'weiSuggestLink') {
      input.value = 'token-list.wei';
      renderTokenList('token-list.wei');
      resolveWeiList('token-list.wei');
    }
  });
}

let fromToken = "ETH";
let toToken = "USDC";
let _balSeq = 0;
let slippageBps = 50;

// ---- Token Icons ----
const ETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></svg>`;
const USDC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#2775CA" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/><path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/></g></g></svg>`;
const USDT_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#26A17B"/><path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/></g></svg>`;
const WBTC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#F7931A"/><path fill="#FFF" fill-rule="nonzero" d="M23.189 14.02c.314-2.096-1.283-3.223-3.465-3.975l.708-2.84-1.728-.43-.69 2.765c-.454-.114-.92-.22-1.385-.326l.695-2.783L15.596 6l-.708 2.839c-.376-.086-.746-.17-1.104-.26l.002-.009-2.384-.595-.46 1.846s1.283.294 1.256.312c.7.175.826.638.805 1.006l-.806 3.235c.048.012.11.03.18.057l-.183-.045-1.13 4.532c-.086.212-.303.531-.793.41.018.025-1.256-.313-1.256-.313l-.858 1.978 2.25.561c.418.105.828.215 1.231.318l-.715 2.872 1.727.43.708-2.84c.472.127.93.245 1.378.357l-.706 2.828 1.728.43.715-2.866c2.948.558 5.164.333 6.097-2.333.752-2.146-.037-3.385-1.588-4.192 1.13-.26 1.98-1.003 2.207-2.538zm-3.95 5.538c-.533 2.147-4.148.986-5.32.695l.95-3.805c1.172.293 4.929.872 4.37 3.11zm.535-5.569c-.487 1.953-3.495.96-4.47.717l.86-3.45c.975.243 4.118.696 3.61 2.733z"/></g></svg>`;
const WSTETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M9.437 14.864l-.181.275c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 0 0 0 0-6.536-12.452z" fill="#FFF"/><path opacity=".6" d="M15.997 18.611l-6.56-3.747c6.56 12.452 6.56 12.452 6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".6" d="M22.563 14.864l.181.275c2.048 3.097 1.603 7.253-1.034 9.824-1.561 1.521-3.622 2.353-5.683 2.353 0 0 0 0 6.536-12.452z" fill="#FFF"/><path opacity=".2" d="M16.003 18.611l6.56-3.747c-6.56 12.452-6.56 12.452-6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/></g></svg>`;
const RETH_ICON = `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#FFAA6B;stop-opacity:1"/><stop offset="100%" style="stop-color:#FF8A5B;stop-opacity:1"/></linearGradient></defs><circle cx="100" cy="100" r="95" fill="#FFC93D"/><circle cx="100" cy="100" r="88" fill="#FF6B6B"/><circle cx="100" cy="100" r="82" fill="url(#bgGradient)"/><g transform="translate(100, 100) rotate(45)"><path d="M -8 -25 C -8 -30, -5 -35, 0 -35 C 5 -35, 8 -30, 8 -25 L 8 -5 L 18 5 L 18 15 L 8 10 L 8 20 L 0 25 L -8 20 L -8 10 L -18 15 L -18 5 L -8 -5 Z" fill="white"/><circle cx="0" cy="-20" r="4" fill="#FF8A5B"/><path d="M -6 20 L -9 35 L -3 30 L 0 38 L 3 30 L 9 35 L 6 20 Z" fill="white"/></g></svg>`;
const DAI_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/><path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/></g></svg>`;
const PNKSTR_ICON = `<svg width="24" height="24" viewBox="0 0 296 296" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision"><style>#em3zDC0HIkr3{animation:em3zDC0HIkr3__rd 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3__rd{0%{rx:93.77px;ry:93.77px}3.125%{rx:93.77px;ry:93.77px}18.75%{rx:93.77px;ry:93.77px}34.375%{rx:93.77px;ry:93.77px}56.25%{rx:0px;ry:0px}93.75%{rx:0px;ry:0px}100%{rx:0px;ry:0px}}#em3zDC0HIkr3_to{animation:em3zDC0HIkr3_to__to 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_to__to{0%{transform:translate(180.943141px,95.15235px)}3.125%{transform:translate(180.943141px,95.15235px)}18.75%{transform:translate(180.122px,95.152354px)}34.375%{transform:translate(148.075px,148.655006px)}56.25%{transform:translate(148.5px,148.655005px)}71.875%{transform:translate(180.122px,120.865004px)}84.375%{transform:translate(180.122px,95.152352px)}93.75%{transform:translate(180.122px,95.152351px)}100%{transform:translate(180.122px,95.152351px)}}#em3zDC0HIkr3_tr{animation:em3zDC0HIkr3_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_tr__tr{0%{transform:rotate(0deg)}34.375%{transform:rotate(0deg)}42.5%{transform:rotate(90deg)}100%{transform:rotate(90deg)}}#em3zDC0HIkr3_ts{animation:em3zDC0HIkr3_ts__ts 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_ts__ts{0%{transform:scale(0,0)}3.125%{transform:scale(0,0)}18.75%{transform:scale(0.8,0.8)}34.375%{transform:scale(1.319281,1.320365)}56.25%{transform:scale(1,1)}71.875%{transform:scale(0.697529,0.658712)}93.75%{transform:scale(0,0)}100%{transform:scale(0,0)}}#em3zDC0HIkr12_tr{animation:em3zDC0HIkr12_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_tr__tr{0%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(135.33781px,207.03926px) rotate(532.987013deg)}}#em3zDC0HIkr12{animation:em3zDC0HIkr12_f_p 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_f_p{0%{fill:#d2dbed}24.0625%{fill:#d2dbec}31.25%{fill:#d2dbed}55.3125%{fill:#d2dbec}62.5%{fill:#d2dbed}86.5625%{fill:#d2dbec}93.75%{fill:#d2dbed}100%{fill:#d2dbed}}#em3zDC0HIkr13_tr{animation:em3zDC0HIkr13_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr13_tr__tr{0%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(11.12px,29.9px) rotate(-532.987013deg)}}</style><circle r="148" transform="translate(148 148)" fill="#0d0d0d"/><g id="em3zDC0HIkr3_to" transform="translate(180.943141,95.15235)"><g id="em3zDC0HIkr3_tr" transform="rotate(0)"><g id="em3zDC0HIkr3_ts" transform="scale(0,0)"><rect id="em3zDC0HIkr3" width="187.538" height="187.538" rx="93.77" ry="93.77" transform="translate(-93.769,-93.769005)" fill="#f2f2f2"/></g></g></g><g style="mix-blend-mode:difference"><path d="M141.692,120.865v-43.1014h11.213v43.1014h-11.213ZM125.299,78.8923v-9.4526h43.857v9.4526h-43.857Zm53.228,41.9727L164.05,69.4397h11.425l9.51,39.2913h-.923l10.007-39.2913h10.716l9.864,39.2913h-.852l9.581-39.2913h11.567L220.184,120.865h-12.135l-9.084-36.0472h.994l-9.155,36.0472h-12.277Z" fill="#fff"/></g></svg>`;
const DEFAULT_ICON = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="12" font-weight="bold">?</text></svg>`;

const ICONS = {
  ETH: ETH_ICON, USDC: USDC_ICON, USDT: USDT_ICON, WBTC: WBTC_ICON,
  wstETH: WSTETH_ICON, rETH: RETH_ICON, DAI: DAI_ICON, PNKSTR: PNKSTR_ICON,
};

// ---- Icon generation for custom tokens ----
const _letterIconCache = new Map();
function iconForSymbol(sym) {
  const s = String(sym);
  if (ICONS[s]) return ICONS[s];
  const t = tokens[s];
  if (t?.icon) return `<img src="${escAttr(t.icon)}" width="24" height="24" style="border-radius:50%" alt="${escAttr(s)}">`;
  if (_letterIconCache.has(s)) return _letterIconCache.get(s);
  const svg = makeLetterIcon(s);
  _letterIconCache.set(s, svg);
  return svg;
}

function makeLetterIcon(sym) {
  try {
    const full = String(sym ?? '').trim();
    const clean = full.toUpperCase().replace(/[^A-Z0-9]/g, '') || '?';
    const show = clean.length <= 5 ? clean : clean.slice(0, 4) + 'â€¦';
    const L = show.length;
    const fontSize = L <= 1 ? 8.2 : L === 2 ? 7.4 : L === 3 ? 6.3 : L === 4 ? 5.4 : 4.6;
    let hue = 0;
    for (let i = 0, n = Math.min(clean.length, 12); i < n; i++) {
      hue = (hue * 31 + clean.charCodeAt(i)) % 360;
    }
    return `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-label="${escAttr(full)}">` +
      `<title>${escText(full)}</title>` +
      `<circle cx="12" cy="12" r="11" fill="hsl(${hue},70%,55%)" stroke="#000" stroke-width="2"/>` +
      `<text x="12" y="12.2" text-anchor="middle" dominant-baseline="middle"` +
      ` font-family="Helvetica,Arial,sans-serif"` +
      ` font-size="${fontSize}" font-weight="700" fill="#fff">${escText(show)}</text>` +
      `</svg>`;
  } catch (e) {
    return DEFAULT_ICON;
  }
}

// ---- RPC fallback system ----
const RPCS = [
  "https://eth.llamarpc.com",
  "https://ethereum.publicnode.com",
  "https://1rpc.io/eth",
  "https://rpc.ankr.com/eth",
];

function makeWalletReader() {
  try {
    if (!window.ethereum) return null;
    const bp = new ethers.BrowserProvider(window.ethereum, CHAIN_ID);
    return bp;
  } catch { return null; }
}

function makeFallbackProvider(urls) {
  const network = { chainId: CHAIN_ID, name: "mainnet" };
  const nodes = urls.map(u => ({
    url: u,
    p: new ethers.JsonRpcProvider(u, network, { batchMaxCount: 10 }),
    downUntil: 0,
    warmed: false,
    ok: true,
  }));

  const walletReader = makeWalletReader();
  if (walletReader) {
    nodes.push({
      url: "wallet",
      p: walletReader,
      downUntil: 0,
      warmed: true,
      ok: true,
    });
  }

  const withTimeout = (ms, work) =>
    Promise.race([
      work(),
      new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), ms)),
    ]);

  const isInfraErr = (e) => {
    const s = String(e?.message || "");
    return /server response 400\b/i.test(s) ||
      /502|503|504|ECONNRESET|ENETUNREACH|EAI_AGAIN|Failed to fetch/i.test(s) ||
      /failed to detect network|timeout|timed out|ETIMEDOUT/i.test(s);
  };
  const isAuthErr = (e) => /Unauthorized|invalid api key|403|401/i.test(String(e?.message || ""));

  return {
    async call(fn) {
      const now = Date.now();
      let lastErr;
      const candidates = nodes
        .filter(n => n.ok && n.downUntil <= now)
        .concat(nodes.filter(n => n.ok && n.downUntil > now));

      for (const n of candidates) {
        try {
          if (!n.warmed && n.url !== "wallet") {
            await withTimeout(1200, () => n.p.getNetwork());
            n.warmed = true;
          }
          const res = await withTimeout(3500, () => fn(n.p));
          n.downUntil = 0;
          return res;
        } catch (e) {
          lastErr = e;
          if (isAuthErr(e)) n.ok = false;
          else if (isInfraErr(e)) n.downUntil = Date.now() + 30_000;
        }
      }
      throw lastErr || new Error("All RPCs failed");
    },
  };
}

const quoteRPC = makeFallbackProvider(RPCS);

// ---- Formatting helpers ----
const fmt = (nStr, max = 6) => {
  if (nStr == null) return "--";
  const n = Number(nStr);
  if (!Number.isFinite(n) || Math.abs(n) >= 1e21) {
    const s = String(nStr);
    return s.includes(".")
      ? s.replace(new RegExp(`(\\.\\d{0,${max}}).*$`), "$1").replace(/\.?0+$/, "")
      : s;
  }
  return n.toLocaleString(undefined, { maximumFractionDigits: max });
};

// ---- Allowance cache ----
const _allowTTLms = 10_000;
const _allowCache = new Map();
const _allowKey = (token, owner, spender) =>
  `${token.toLowerCase()}:${owner.toLowerCase()}:${spender.toLowerCase()}`;

function cacheSetAllowance(token, owner, spender, v) {
  _allowCache.set(_allowKey(token, owner, spender), { v, t: Date.now() });
}
function cacheGetAllowance(token, owner, spender) {
  const hit = _allowCache.get(_allowKey(token, owner, spender));
  return hit && Date.now() - hit.t < _allowTTLms ? hit.v : null;
}

// ---- Multicall3 batched reads ----
const MULTICALL3_IFACE = new ethers.Interface([
  "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])",
  "function getEthBalance(address addr) view returns (uint256 balance)",
]);
const MC_BAL_IFACE = new ethers.Interface([
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address,address) view returns (uint256)",
]);
const _balanceCache = new Map(); // key â†’ { v: bigint, t: number }
const _BAL_TTL = 15_000;

function getCachedBalance(tokenAddress) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  const hit = _balanceCache.get(key);
  return (hit && Date.now() - hit.t < _BAL_TTL) ? hit.v : null;
}
function setCachedBalance(tokenAddress, value) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  _balanceCache.set(key, { v: value, t: Date.now() });
}

async function multicallRead(calls) {
  if (calls.length === 0) return [];
  const calldata = MULTICALL3_IFACE.encodeFunctionData("aggregate3", [
    calls.map(c => [c.target, c.allowFailure, c.callData])
  ]);
  const rpc = provider || await quoteRPC.call(r => r);
  const raw = await rpc.call({ to: MULTICALL3_ADDRESS, data: calldata });
  return MULTICALL3_IFACE.decodeFunctionResult("aggregate3", raw)[0];
}

async function fetchModalBalances() {
  if (!connectedAddress) return;
  const allTokens = Object.values(tokens);
  const calls = [];
  const meta = [];
  const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

  // ETH balance
  calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
    callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
  meta.push({ type: 'eth' });

  // All ERC-20 balances
  for (const t of allTokens) {
    if (t.address === ZERO_ADDRESS) continue;
    calls.push({ target: t.address, allowFailure: true, callData: balOfData });
    meta.push({ type: 'erc20', address: t.address });
  }

  try {
    const results = await multicallRead(calls);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i];
      const r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          setCachedBalance(ZERO_ADDRESS, MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0]);
        } else {
          setCachedBalance(m.address, MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0]);
        }
      } catch {}
    }
    // Re-render to show fetched balances
    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    console.warn("Multicall3 modal balances failed:", e);
  }
}

function safeParseUnits(valStr, decimals) {
  const s = String(valStr).trim();
  if (!s) throw new Error("Empty amount");
  const m = s.match(/^(\d+)(?:\.(\d+))?$/);
  if (!m) throw new Error("Invalid number");
  const frac = m[2] || "";
  if (frac.length > decimals) throw new Error(`Too many decimals (max ${decimals})`);
  return ethers.parseUnits(s, decimals);
}

// ---- Permit config ----
const PERMIT_CONFIG = {
  [USDC_ADDRESS.toLowerCase()]: {
    type: 'eip2612',
    domain: { name: 'USD Coin', version: '2', chainId: 1, verifyingContract: USDC_ADDRESS },
    routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  },
  [DAI_ADDRESS.toLowerCase()]: {
    type: 'dai',
    domain: { name: 'Dai Stablecoin', version: '1', chainId: 1, verifyingContract: DAI_ADDRESS },
    routerFn: 'permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)',
  },
};

// ---- Generic EIP-2612 permit detection ----
const _permitCache = new Map(); // address â†’ config | null

const _permitIface = new ethers.Interface([
  'function eip712Domain() view returns (bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)',
  'function nonces(address) view returns (uint256)',
  'function DOMAIN_SEPARATOR() view returns (bytes32)',
  'function name() view returns (string)',
  'function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
]);

async function _staticCall(tokenAddress, data) {
  return await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data }));
}

async function detectPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  if (_permitCache.has(key)) return _permitCache.get(key);

  try {
    // Quick check: does it have nonces() and DOMAIN_SEPARATOR()?
    const [nonceRes, dsRes] = await Promise.all([
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('nonces', [ZERO_ADDRESS])),
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('DOMAIN_SEPARATOR')),
    ]);
    // If either reverts, quoteRPC throws or returns 0x
    if (!nonceRes || nonceRes === '0x' || !dsRes || dsRes === '0x') throw new Error('no permit');

    // Try EIP-5267 eip712Domain() first
    let domainName, domainVersion;
    try {
      const domRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('eip712Domain'));
      const decoded = _permitIface.decodeFunctionResult('eip712Domain', domRes);
      domainName = decoded[1];
      domainVersion = decoded[2];
    } catch (_) {
      // Fallback: read name() and try version "1"
      const nameRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('name'));
      domainName = _permitIface.decodeFunctionResult('name', nameRes)[0];
      domainVersion = '1';
    }

    // Verify by computing the expected DOMAIN_SEPARATOR
    const candidateDomain = { name: domainName, version: domainVersion, chainId: CHAIN_ID, verifyingContract: tokenAddress };
    const computed = ethers.TypedDataEncoder.hashDomain(candidateDomain);
    const onchain = ethers.AbiCoder.defaultAbiCoder().decode(['bytes32'], dsRes)[0];
    if (computed !== onchain) {
      // Try version "2" as fallback
      candidateDomain.version = '2';
      const computed2 = ethers.TypedDataEncoder.hashDomain(candidateDomain);
      if (computed2 !== onchain) {
        _permitCache.set(key, null);
        return null;
      }
    }

    const config = {
      type: 'eip2612',
      domain: candidateDomain,
      routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
    };
    _permitCache.set(key, config);
    return config;
  } catch (_) {
    _permitCache.set(key, null);
    return null;
  }
}

async function getPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  return await detectPermitConfig(tokenAddress);
}

async function signPermit(config, tokenAddress) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const owner = connectedAddress;
  const spender = ZROUTER_ADDRESS;

  // Fetch nonce from token contract
  const nonceData = _permitIface.encodeFunctionData('nonces', [owner]);
  const nonceResult = await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data: nonceData }));
  const nonce = _permitIface.decodeFunctionResult('nonces', nonceResult)[0];

  let types, values;
  if (config.type === 'dai') {
    types = {
      Permit: [
        { name: 'holder', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'expiry', type: 'uint256' },
        { name: 'allowed', type: 'bool' },
      ],
    };
    values = { holder: owner, spender, nonce, expiry: deadline, allowed: true };
  } else {
    types = {
      Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    };
    values = { owner, spender, value: ethers.MaxUint256, nonce, deadline };
  }

  const sig = await signer.signTypedData(config.domain, types, values);
  const { v, r, s } = ethers.Signature.from(sig);
  return { v, r, s, nonce, deadline, config };
}

function decodeMulticallCalls(multicallData) {
  try {
    const decoded = ROUTER_IFACE.decodeFunctionData('multicall', multicallData);
    return Array.from(decoded[0]);
  } catch (e) {
    return [];
  }
}

function buildPermitMulticall(calls, permitData) {
  let permitCall;
  if (permitData.config.type === 'dai') {
    permitCall = ROUTER_IFACE.encodeFunctionData('permitDAI', [permitData.nonce, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  } else {
    permitCall = ROUTER_IFACE.encodeFunctionData('permit', [permitData.config.domain.verifyingContract, ethers.MaxUint256, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  }
  return ROUTER_IFACE.encodeFunctionData('multicall', [[permitCall, ...calls]]);
}

// ---- Permit2 SignatureTransfer support ----
const PERMIT2_DOMAIN = { name: "Permit2", chainId: CHAIN_ID, verifyingContract: PERMIT2_ADDRESS };
const PERMIT2_TYPES = {
  PermitTransferFrom: [
    { name: "permitted", type: "TokenPermissions" },
    { name: "spender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
  ],
  TokenPermissions: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint256" },
  ],
};

async function checkPermit2Allowance(tokenAddress) {
  let a = cacheGetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS);
  if (a != null) return a;
  const r = erc20Read(tokenAddress);
  a = await r.allowance(connectedAddress, PERMIT2_ADDRESS);
  cacheSetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS, a);
  return a;
}

async function signPermit2(tokenAddress, amount) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const nonce = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
  const values = {
    permitted: { token: tokenAddress, amount },
    spender: ZROUTER_ADDRESS,
    nonce,
    deadline,
  };
  const sig = await signer.signTypedData(PERMIT2_DOMAIN, PERMIT2_TYPES, values);
  return { signature: sig, nonce, deadline, token: tokenAddress, amount };
}

function buildPermit2Multicall(calls, p2) {
  const p2call = ROUTER_IFACE.encodeFunctionData('permit2TransferFrom', [p2.token, p2.amount, p2.nonce, p2.deadline, p2.signature]);
  return ROUTER_IFACE.encodeFunctionData('multicall', [[p2call, ...calls]]);
}

// ---- ERC20 readers (cached, recreated on provider change) ----
const _erc20Read = new Map();
function erc20Read(address) {
  const k = address.toLowerCase();
  if (!_erc20Read.has(k)) {
    _erc20Read.set(k, new ethers.Contract(
      address,
      ["function allowance(address,address) view returns (uint256)"],
      provider
    ));
  }
  return _erc20Read.get(k);
}

// ---- Balance updates (Multicall3 batched) ----
async function updateBalances() {
  if (!provider || !connectedAddress) return;

  const seq = ++_balSeq;
  const fromSnap = fromToken, toSnap = toToken;
  const f = tokens[fromSnap], t = tokens[toSnap];
  const fromIsEth = f.address === ZERO_ADDRESS;
  const toIsEth = t.address === ZERO_ADDRESS;

  try {
    const calls = [];
    const meta = [];
    const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

    // ETH balance via getEthBalance
    if (fromIsEth || toIsEth) {
      calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
        callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
      meta.push({ type: 'eth' });
    }
    // From token balance
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true, callData: balOfData });
      meta.push({ type: 'erc20', key: f.address.toLowerCase() });
    }
    // To token balance (if different)
    if (!toIsEth) {
      const keyT = t.address.toLowerCase();
      if (fromIsEth || keyT !== f.address.toLowerCase()) {
        calls.push({ target: t.address, allowFailure: true, callData: balOfData });
        meta.push({ type: 'erc20', key: keyT });
      }
    }
    // Batch allowance reads for from token (saves RPCs during quote/swap)
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, ZROUTER_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: ZROUTER_ADDRESS });
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, PERMIT2_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: PERMIT2_ADDRESS });
    }

    const results = await multicallRead(calls);
    if (seq !== _balSeq || fromSnap !== fromToken || toSnap !== toToken) return;

    const balances = Object.create(null);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i], r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          balances.ETH = MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0];
          setCachedBalance(ZERO_ADDRESS, balances.ETH);
        } else if (m.type === 'erc20') {
          balances[m.key] = MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0];
          setCachedBalance(m.key, balances[m.key]);
        } else if (m.type === 'allow') {
          cacheSetAllowance(m.token, connectedAddress, m.spender,
            MC_BAL_IFACE.decodeFunctionResult("allowance", r.returnData)[0]);
        }
      } catch {}
    }

    const fromStr = fromIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[f.address.toLowerCase()] ?? 0n, f.decimals))} ${f.symbol}`;
    const toStr = toIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[t.address.toLowerCase()] ?? 0n, t.decimals))} ${t.symbol}`;

    setText("fromBalance", `Balance: ${fromStr}`);
    setText("toBalance", `Balance: ${toStr}`);
  } catch (e) {
    console.error("Balance update error:", e);
  }
}

// ---- AMM names ----
const AMM_NAMES = {
  0: "Uniswap V2", 1: "SushiSwap", 2: "zAMM",
  3: "Uniswap V3", 4: "Uniswap V4", 5: "Curve",
  6: "Lido", 7: "WETH Wrap", 8: "V4 Hooked",
};

// ---- Hoisted ABIs / Interfaces (avoid re-parsing per call) ----
const QUOTER_IFACE = new ethers.Interface([
  "function buildBestSwapViaETHMulticall(address to,address refundTo,bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, bytes[] calls, bytes multicall, uint256 msgValue)",
  "function buildSplitSwap(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function getQuotes(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) best, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[] quotes)",
  "function quoteCurve(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 maxCandidates) view returns (uint256 amountIn,uint256 amountOut,address bestPool,bool usedUnderlying,bool usedStable,uint8 iIndex,uint8 jIndex)",
  "function quoteV4(bool,address,address,uint24,int24,address,uint256) view returns (uint256 amountIn, uint256 amountOut)",
]);
const V4_SWAP_IFACE = new ethers.Interface([
  "function swapExactTokensForTokens(uint256,uint256,bool,(address,address,uint24,int24,address),bytes,address,uint256) payable returns (int256)",
]);
const ROUTER_IFACE = new ethers.Interface([
  "function deposit(address,uint256,uint256) payable",
  "function execute(address,uint256,bytes) payable returns (bytes)",
  "function multicall(bytes[]) payable returns (bytes[])",
  "function permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
  "function permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)",
  "function permit2TransferFrom(address token, uint256 amount, uint256 nonce, uint256 deadline, bytes signature)",
]);

// ---- Quote refresh timer ----
let _refreshTimer = null;
let _refreshCountdown = 0;

function startQuoteRefresh() {
  stopQuoteRefresh();
  _refreshCountdown = 15;
  setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  _refreshTimer = setInterval(() => {
    _refreshCountdown--;
    if (_refreshCountdown <= 0) {
      _refreshCountdown = 15;
      handleAmountChange();
    }
    setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  }, 1000);
}

function stopQuoteRefresh() {
  if (_refreshTimer) { clearInterval(_refreshTimer); _refreshTimer = null; }
  _refreshCountdown = 0;
  setText('quoteCountdown', '');
}

function manualRefresh() {
  handleAmountChange();
  // Timer restarted by handleAmountChange on success
}

// ---- Quoting ----
let _quoteSeq = 0;

async function handleAmountChange() {
  const amtStr = $("fromAmount").value.trim();
  const swapBtn = $("swapBtn");
  const toAmountEl = $("toAmount");
  const quoteInfoEl = $("quoteInfo");

  if (!connectedAddress) {
    setText(swapBtn, "Connect Wallet");
    setDisabled(swapBtn, false);
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    toAmountEl.value = "";
    return;
  }

  const amtNum = Number(amtStr);
  if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Enter an amount");
    setDisabled(swapBtn, true);
    return;
  }

  if (fromToken === toToken) {
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Select different tokens");
    setDisabled(swapBtn, true);
    return;
  }

  if (!provider) return;

  const seq = ++_quoteSeq;
  const fromSnap = fromToken, toSnap = toToken;

  try {
    setHTML(swapBtn, `<span class="loading"></span> Getting quote...`);
    setDisabled(swapBtn, true);

    const quote = await requestQuote(amtStr, fromSnap, toSnap);

    if (seq !== _quoteSeq || fromSnap !== fromToken || toSnap !== toToken) return;

    const toData = tokens[toSnap];
    const outStr = ethers.formatUnits(quote.expectedOutput, toData.decimals);
    if (toAmountEl.value !== outStr) toAmountEl.value = outStr;

    // Route display
    const route = quote.isSplit
      ? formatSplitRoute(quote.splitLegs)
      : quote.isTwoHop
        ? `${quote.sourceA} + ${quote.sourceB}`
        : `${quote.sourceA}`;
    fitRouteText(route);

    // Price impact
    displayPriceImpact(amtStr, fromSnap, toSnap, quote);

    // All routes
    displayAllRoutes(quote, toSnap);

    setShown(quoteInfoEl, true);
    startQuoteRefresh();

    // Allowance check
    const fromData = tokens[fromSnap];
    let btnLabel = "Swap";
    if (fromData.address !== ZERO_ADDRESS) {
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      let allowance = cacheGetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS);
      if (allowance == null) {
        const r = erc20Read(fromData.address);
        allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
        cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);
      }
      if (allowance < amountIn) {
        const [permitCfg, p2Allowance] = await Promise.all([
          getPermitConfig(fromData.address),
          checkPermit2Allowance(fromData.address),
        ]);
        btnLabel = (permitCfg || p2Allowance >= amountIn) ? "Swap" : "Approve & Swap";
      }
    }

    setText(swapBtn, btnLabel);
    setDisabled(swapBtn, false);
  } catch (e) {
    console.error("Quote error:", e);
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    const msg = /Too many decimals|Invalid number|Empty amount/i.test(String(e?.message || ""))
      ? e.message : "Quote failed";
    setText(swapBtn, msg);
    setDisabled(swapBtn, true);
    setTimeout(() => {
      if (seq === _quoteSeq) {
        setText(swapBtn, "Enter an amount");
        setDisabled(swapBtn, true);
      }
    }, 1500);
  }
}

async function setMaxFromBalance() {
  try {
    if (!provider || !connectedAddress) {
      toggleWallet();
      return;
    }

    const f = tokens[fromToken];
    let raw = getCachedBalance(f.address);

    if (raw == null) {
      // Cache miss â€” single fallback RPC
      if (f.address === ZERO_ADDRESS) {
        raw = await provider.getBalance(connectedAddress);
      } else {
        const c = new ethers.Contract(f.address,
          ["function balanceOf(address) view returns (uint256)"], provider);
        raw = await c.balanceOf(connectedAddress);
      }
      setCachedBalance(f.address, raw);
    }

    // Reserve 5% for gas when sending ETH
    if (f.address === ZERO_ADDRESS) raw = (raw * 95n) / 100n;

    const maxStr = ethers.formatUnits(raw, f.decimals);
    const pretty = maxStr.includes(".") ? maxStr.replace(/\.?0+$/, "") : maxStr;

    const input = $("fromAmount");
    input.value = pretty || "0";
    handleAmountChange();
  } catch (e) {
    console.error("MAX error:", e);
  }
}

// ---- Slippage ----
const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
function readSlippage(finalize = false) {
  const el = $("slippagePct");
  if (!el) return;
  const raw = el.value;
  let v = parseFloat(raw);
  if (Number.isFinite(v)) {
    v = clamp(v, 0, 20);
    slippageBps = Math.round(v * 100);
    if (finalize) {
      const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
      el.value = v.toFixed(stepDigits);
    }
  } else if (finalize) {
    const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
    el.value = clamp(slippageBps / 100, 0, 20).toFixed(stepDigits);
  }
}

function initSimpleSlippage() {
  const el = $("slippagePct");
  if (!el || el.dataset.inited === "1") return;
  el.dataset.inited = "1";
  readSlippage(false);

  const reQuote = debounce(() => {
    const amt = $("fromAmount")?.value;
    if (amt) handleAmountChange();
  }, 250);

  el.addEventListener("input", () => { readSlippage(false); reQuote(); });
  el.addEventListener("blur", () => { readSlippage(true); reQuote(); });
  el.addEventListener("keydown", (e) => {
    if (e.key !== "ArrowUp" && e.key !== "ArrowDown") return;
    e.preventDefault();
    const step = parseFloat(el.step || "0.01") || 0.01;
    const digits = (String(step).split(".")[1] || "").length;
    const cur = parseFloat(el.value || "0") || 0;
    const dir = e.key === "ArrowUp" ? 1 : -1;
    const next = clamp(cur + dir * step, 0, 20);
    el.value = next.toFixed(digits);
    readSlippage(true);
    reQuote();
  });
}
document.addEventListener("DOMContentLoaded", initSimpleSlippage);

// ---- Quote via RPC ----
function getReceiver() {
  const v = ($("receiverAddress")?.value || "").trim();
  if (v && ethers.isAddress(v) && v !== ZERO_ADDRESS) return ethers.getAddress(v);
  return connectedAddress;
}

async function getV4HookedQuote(rpc, amountIn, fromAddr, toAddr, receiver, deadline, slipBps) {
  // Only activate for ETHâ†”PNKSTR swaps
  const isETHToPNKSTR = fromAddr === ZERO_ADDRESS && toAddr.toLowerCase() === PNKSTR_ADDRESS.toLowerCase();
  const isPNKSTRToETH = fromAddr.toLowerCase() === PNKSTR_ADDRESS.toLowerCase() && toAddr === ZERO_ADDRESS;
  if (!isETHToPNKSTR && !isPNKSTRToETH) return null;

  // Quote via zQuoter.quoteV4 â€” a view function, no ETH/token balance needed.
  // PNKSTR pool: fee=0 (hook-managed dynamic fee), tickSpacing=60.
  // quoteV4 reads the current dynamic fee from slot0.lpFee (set by the hook via
  // updateDynamicLPFee) and uses it in SwapMath.computeSwapStep, so the ~10% hook
  // tax is reflected in the quote. No ERC20 transfer tax on PNKSTR itself.
  const quoter = new ethers.Contract(ZQUOTER_ADDRESS, QUOTER_IFACE, rpc);

  let amountOut;
  try {
    const result = await quoter.quoteV4(
      false, fromAddr, toAddr, 0, 60, PNKSTR_HOOK_ADDRESS, amountIn
    );
    amountOut = result.amountOut;
    if (amountOut <= 0n) return null;
  } catch (e) {
    console.warn("V4 hooked quote failed:", e);
    return null;
  }

  // Build execution calldata with slippage
  const poolKey = [ZERO_ADDRESS, PNKSTR_ADDRESS, 0, 60, PNKSTR_HOOK_ADDRESS];
  const zeroForOne = isETHToPNKSTR;
  const amountOutMin = amountOut * (10000n - BigInt(slipBps)) / 10000n;
  const execSwapData = V4_SWAP_IFACE.encodeFunctionData("swapExactTokensForTokens", [
    amountIn, amountOutMin, zeroForOne, poolKey, "0x", receiver, deadline
  ]);

  let multicall, msgValue;
  if (isETHToPNKSTR) {
    const executeCall = ROUTER_IFACE.encodeFunctionData("execute", [V4_ROUTER_ADDRESS, amountIn, execSwapData]);
    multicall = ROUTER_IFACE.encodeFunctionData("multicall", [[executeCall]]);
    msgValue = amountIn;
  } else {
    const depositCall = ROUTER_IFACE.encodeFunctionData("deposit", [PNKSTR_ADDRESS, 0n, amountIn]);
    const executeCall = ROUTER_IFACE.encodeFunctionData("execute", [V4_ROUTER_ADDRESS, 0n, execSwapData]);
    multicall = ROUTER_IFACE.encodeFunctionData("multicall", [[depositCall, executeCall]]);
    msgValue = 0n;
  }

  return { amountOut, multicall, msgValue };
}

async function getQuote(fromAmountStr, fromSym, toSym) {
  if (!connectedAddress) throw new Error("Connect wallet to get a quote");
  const fromData = tokens[fromSym], toData = tokens[toSym];
  if (!fromData || !toData) throw new Error("Unknown token");
  if (fromData.address === toData.address) throw new Error("Same token");

  const receiver = getReceiver();
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);

  return await quoteRPC.call(async (rpc) => {
    const quoter = new ethers.Contract(ZQUOTER_ADDRESS, QUOTER_IFACE, rpc);
    const callOpts = { blockTag: "latest" };

    // Fire all calls in parallel (V4 hooked only for PNKSTR swaps)
    const isPNKSTR = fromData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase()
      || toData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase();
    const allCalls = [
      quoter.buildBestSwapViaETHMulticall(
        receiver, connectedAddress, false,
        fromData.address, toData.address,
        amountIn, BigInt(slippageBps), deadline, callOpts
      ),
      quoter.buildSplitSwap(
        receiver, fromData.address, toData.address,
        amountIn, BigInt(slippageBps), deadline, callOpts
      ),
      quoter.getQuotes(false, fromData.address, toData.address, amountIn, callOpts),
      quoter.quoteCurve(false, fromData.address, toData.address, amountIn, 8, callOpts),
    ];
    if (isPNKSTR) allCalls.push(getV4HookedQuote(rpc, amountIn, fromData.address, toData.address, receiver, deadline, slippageBps));
    const [bestResult, splitResult, quotesResult, curveResult, v4HookedResult] = await Promise.allSettled(allCalls);

    // bestResult is required
    if (bestResult.status === 'rejected') throw bestResult.reason;
    const r = bestResult.value;

    const isTwoHop = r.b.amountOut > 0n;
    const bestOutput = isTwoHop ? r.b.amountOut : r.a.amountOut;

    let result = {
      expectedOutput: bestOutput,
      multicall: r.multicall,
      calls: r.calls,
      msgValue: r.msgValue ?? 0n,
      isTwoHop,
      isSplit: false,
      splitLegs: null,
      sourceA: AMM_NAMES[r.a.source] || "Unknown",
      sourceB: isTwoHop ? (AMM_NAMES[r.b.source] || "Unknown") : null,
      allQuotes: null,
    };

    // Check if split beats best
    if (splitResult.status === 'fulfilled') {
      const s = splitResult.value;
      const splitTotal = s.legs[0].amountOut + s.legs[1].amountOut;
      if (splitTotal > bestOutput && s.legs[0].amountOut > 0n && s.legs[1].amountOut > 0n) {
        result.expectedOutput = splitTotal;
        result.multicall = s.multicall;
        result.msgValue = s.msgValue ?? 0n;
        result.isSplit = true;
        result.isTwoHop = false;
        result.splitLegs = [
          { source: AMM_NAMES[s.legs[0].source] || "Unknown", amountIn: s.legs[0].amountIn, amountOut: s.legs[0].amountOut, feeBps: s.legs[0].feeBps },
          { source: AMM_NAMES[s.legs[1].source] || "Unknown", amountIn: s.legs[1].amountIn, amountOut: s.legs[1].amountOut, feeBps: s.legs[1].feeBps },
        ];
        // calls not returned by buildSplitSwap; multicall is directly usable
        result.calls = null;
      }
    }

    // Attach all-quotes for display
    if (quotesResult.status === 'fulfilled') {
      const q = quotesResult.value;
      result.allQuotes = q.quotes.map(qt => ({
        source: AMM_NAMES[qt.source] || `AMM #${qt.source}`,
        sourceId: Number(qt.source),
        feeBps: qt.feeBps,
        amountIn: qt.amountIn,
        amountOut: qt.amountOut,
      })).filter(qt => qt.amountOut > 0n);
      // Merge Curve quote if available
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountOut > 0n) {
          result.allQuotes.push({ source: "Curve", sourceId: 5, feeBps: 0n, amountIn: c.amountIn, amountOut: c.amountOut });
        }
      }
    }

    // Check if V4 hooked pool beats current best
    if (v4HookedResult?.status === 'fulfilled' && v4HookedResult.value) {
      const v4 = v4HookedResult.value;
      if (v4.amountOut > 0n) {
        if (result.allQuotes) {
          result.allQuotes.push({ source: "V4 Hooked", sourceId: 8, feeBps: 1000n, amountIn, amountOut: v4.amountOut });
        }
        if (v4.amountOut > result.expectedOutput) {
          result.expectedOutput = v4.amountOut;
          result.multicall = v4.multicall;
          result.msgValue = v4.msgValue;
          result.sourceA = "V4 Hooked";
          result.sourceB = null;
          result.isTwoHop = false;
          result.isSplit = false;
          result.splitLegs = null;
          result.calls = null;
        }
      }
    }

    return result;
  });
}

// ---- Split route formatting ----
function formatSplitRoute(legs) {
  if (!legs || legs.length < 2) return "Split";
  const total = legs[0].amountIn + legs[1].amountIn;
  if (total === 0n) return `${legs[0].source} + ${legs[1].source}`;
  const pct0 = Number(legs[0].amountIn * 100n / total);
  const pct1 = 100 - pct0;
  return `${pct0}% ${legs[0].source} + ${pct1}% ${legs[1].source}`;
}

// ---- All-routes toggle ----
function toggleAllRoutes() {
  const list = $('allRoutesList');
  const chev = $('routesChevron');
  const open = list.style.display !== 'none';
  list.style.display = open ? 'none' : 'block';
  chev.innerHTML = open ? '&#9654;' : '&#9660;';
}

function displayAllRoutes(quote, toSym) {
  const wrap = $('allRoutesWrap');
  const list = $('allRoutesList');
  if (!quote.allQuotes || quote.allQuotes.length === 0) {
    setShown(wrap, false);
    return;
  }
  const toData = tokens[toSym];
  const sorted = [...quote.allQuotes].sort((a, b) => (b.amountOut > a.amountOut ? 1 : b.amountOut < a.amountOut ? -1 : 0));
  const bestAmt = sorted[0].amountOut;
  list.innerHTML = sorted.map(q => {
    const out = fmt(ethers.formatUnits(q.amountOut, toData.decimals));
    const badge = q.amountOut === bestAmt ? '<span class="best-badge">best</span>' : '';
    const fee = Number(q.feeBps);
    const feeLabel = fee > 0 ? ` (${fee >= 100 ? (fee / 100) + '%' : fee + 'bp'})` : '';
    return `<div class="routes-list-item"><span>${escText(q.source)}${escText(feeLabel)}</span><span>${out} ${escText(toData.symbol)}${badge}</span></div>`;
  }).join('');
  setShown(wrap, true);
}

// ---- Price impact via spot rate ----
const _spotCache = new Map();
const _spotTTL = 30_000;

function _spotKey(tokenIn, tokenOut) {
  return `${tokenIn.toLowerCase()}:${tokenOut.toLowerCase()}`;
}

async function getSpotRate(fromSym, toSym) {
  const fromData = tokens[fromSym], toData = tokens[toSym];
  const key = _spotKey(fromData.address, toData.address);
  const cached = _spotCache.get(key);
  if (cached && Date.now() - cached.t < _spotTTL) return cached.rate;

  // Use a small reference amount: 10^(decimals-2) or at least 1 unit
  const refExp = Math.max(0, fromData.decimals - 2);
  const refAmount = 10n ** BigInt(refExp);

  try {
    const spotRate = await quoteRPC.call(async (rpc) => {
      const quoter = new ethers.Contract(ZQUOTER_ADDRESS, QUOTER_IFACE, rpc);
      const q = await quoter.getQuotes(false, fromData.address, toData.address, refAmount, { blockTag: "latest" });
      if (q.best.amountOut === 0n || q.best.amountIn === 0n) return null;
      // Rate = amountOut / amountIn (both as BigInt, compute as float)
      return Number(q.best.amountOut) / Number(q.best.amountIn);
    });
    if (spotRate != null) {
      _spotCache.set(key, { rate: spotRate, t: Date.now() });
    }
    return spotRate;
  } catch (e) {
    console.warn("Spot rate fetch failed:", e);
    return null;
  }
}

async function displayPriceImpact(amtStr, fromSym, toSym, quote) {
  const el = $('impactInfo');
  if (!el) return;
  const seq = _quoteSeq; // capture to detect staleness after await
  try {
    const fromData = tokens[fromSym], toData = tokens[toSym];
    const amountIn = safeParseUnits(amtStr, fromData.decimals);
    const executionRate = Number(quote.expectedOutput) / Number(amountIn);

    const spotRate = await getSpotRate(fromSym, toSym);
    if (seq !== _quoteSeq) return; // stale â€” newer quote already in flight
    if (spotRate == null || spotRate === 0) {
      el.textContent = '--';
      el.className = '';
      return;
    }

    const impact = (1 - executionRate / spotRate) * 100;
    const displayImpact = Math.max(0, impact);
    el.textContent = displayImpact < 0.01 ? '<0.01%' : displayImpact.toFixed(2) + '%';

    if (displayImpact > 5) {
      el.className = 'impact-danger';
    } else if (displayImpact > 2) {
      el.className = 'impact-warn';
    } else {
      el.className = '';
    }
  } catch (e) {
    el.textContent = '--';
    el.className = '';
  }
}

async function withRetry(task, { tries = 3, base = 120 } = {}) {
  let attempt = 0, lastErr;
  while (attempt < tries) {
    try { return await task(); } catch (e) {
      const s = String(e?.message || "");
      const transient = /missing revert data|CALL_EXCEPTION|timeout|ETIMEDOUT|429|rate/i.test(s);
      if (!transient || attempt === tries - 1) throw e;
      lastErr = e;
      await new Promise(r => setTimeout(r, base * Math.pow(2, attempt)));
      attempt++;
    }
  }
  throw lastErr;
}

let _quoteLock = Promise.resolve();
let _pendingQuoteArgs = null;

let _quoteResult = null;
function requestQuote(amtStr, fromSnap, toSnap) {
  _pendingQuoteArgs = { amtStr, fromSnap, toSnap };
  _quoteLock = _quoteLock.then(async () => {
    const args = _pendingQuoteArgs;
    _pendingQuoteArgs = null;
    if (!args) return _quoteResult;
    const { amtStr, fromSnap, toSnap } = args;
    _quoteResult = await withRetry(() => getQuote(amtStr, fromSnap, toSnap));
    return _quoteResult;
  });
  return _quoteLock;
}

// ---- Swap execution ----
let _swapBusy = false;

async function executeSwap() {
  if (_swapBusy) return;
  _swapBusy = true;
  stopQuoteRefresh();

  const swapBtn = $("swapBtn");
  try {
    if (!signer || !connectedAddress) {
      toggleWallet();
      return;
    }

    const amtStr = $("fromAmount").value;
    const amtNum = parseFloat(amtStr);
    if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
      alert("Please enter an amount");
      return;
    }
    if (fromToken === toToken) {
      alert("Select different tokens");
      return;
    }
    const receiverRaw = ($("receiverAddress")?.value || "").trim();
    if (receiverRaw && !ethers.isAddress(receiverRaw)) {
      alert("Invalid receiver address");
      return;
    }

    swapBtn.innerHTML = `<span class="loading"></span> Getting quote...`;
    swapBtn.disabled = true;

    const fromSnap = fromToken, toSnap = toToken;
    const quote = await withRetry(() => getQuote(amtStr, fromSnap, toSnap));
    const fromData = tokens[fromSnap];
    const amountIn = safeParseUnits(amtStr, fromData.decimals);

    let txData = quote.multicall;

    // ERC20 approval
    if (fromData.address !== ZERO_ADDRESS) {
      const r = erc20Read(fromData.address);
      swapBtn.textContent = "Checking allowance...";
      let allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
      cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);

      if (allowance < amountIn) {
        const permitCfg = await getPermitConfig(fromData.address);
        if (permitCfg) {
          // --- PERMIT PATH (single tx) ---
          swapBtn.textContent = "Sign permit...";
          const permitData = await signPermit(permitCfg, fromData.address);
          const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
          txData = buildPermitMulticall(innerCalls, permitData);
        } else {
          // --- Check Permit2 allowance ---
          let p2Allowance = cacheGetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS);
          if (p2Allowance == null) {
            swapBtn.textContent = "Checking Permit2...";
            const r2 = erc20Read(fromData.address);
            p2Allowance = await r2.allowance(connectedAddress, PERMIT2_ADDRESS);
            cacheSetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS, p2Allowance);
          }
          if (p2Allowance >= amountIn) {
            // --- PERMIT2 PATH (single tx, sign-only) ---
            swapBtn.textContent = "Sign Permit2...";
            const permit2Data = await signPermit2(fromData.address, amountIn);
            const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
            txData = buildPermit2Multicall(innerCalls, permit2Data);
          } else {
            // --- APPROVE PATH (two tx, fallback for non-permit tokens) ---
            swapBtn.textContent = "Approving token...";
            const erc20W = new ethers.Contract(
              fromData.address,
              ["function approve(address,uint256) returns (bool)"],
              signer
            );
            const approveTx = await wcTransaction(
              erc20W.approve(ZROUTER_ADDRESS, ethers.MaxUint256),
              'Approve token spending in your wallet'
            );
            swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
            const rc = await waitForTx(approveTx);
            if (rc.status === 0) throw new Error("Approval transaction failed");
            const fresh = await getQuote(amtStr, fromSnap, toSnap);
            txData = fresh.multicall;
            quote.msgValue = fresh.msgValue;
            cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, ethers.MaxUint256);
          }
        }
      }
    }

    swapBtn.textContent = "Swapping...";
    const txValue = quote.msgValue ?? 0n;

    const swapTx = await wcTransaction(
      signer.sendTransaction({
        to: ZROUTER_ADDRESS,
        data: txData,
        value: txValue,
      }),
      'Confirm swap in your wallet'
    );
    swapBtn.innerHTML = `Confirming swap... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

    const receipt = await waitForTx(swapTx);
    if (receipt.status === 0) throw new Error("Swap transaction failed");

    swapBtn.textContent = "Swap Complete!";
    $("fromAmount").value = "";
    $("toAmount").value = "";
    $("quoteInfo").style.display = "none";
    stopQuoteRefresh();
    setTimeout(() => {
      updateBalances();
      swapBtn.textContent = "Enter an amount";
      swapBtn.disabled = true;
    }, 1500);
  } catch (e) {
    console.error("Swap error:", e);
    let msg = "Swap failed";
    const s = String(e?.message || e?.reason || "");
    if (e.code === 4001 || /user rejected|denied/i.test(s)) msg = "Transaction cancelled";
    else if (/insufficient funds/i.test(s)) msg = "Insufficient balance";
    else if (/Too many decimals|Invalid number/i.test(s)) msg = s;

    swapBtn.textContent = msg;
    setTimeout(() => {
      swapBtn.textContent = "Swap";
      swapBtn.disabled = false;
    }, 2000);
  } finally {
    _swapBusy = false;
  }
}

// ---- Token swap direction ----
function swapTokens() {
  if (fromToken === toToken) return;
  const prevFrom = fromToken, prevTo = toToken;
  const fAmt = $("fromAmount").value;
  const tAmt = $("toAmount").value;

  fromToken = prevTo;
  toToken = prevFrom;
  $("fromAmount").value = tAmt;
  $("toAmount").value = "";
  updateTokenDisplay();
  _quoteSeq++;
  updateBalances();
  if (tAmt) handleAmountChange();
}

function fitRouteText(route) {
  const el = $("routeInfo");
  el.textContent = route;
  el.title = route;
  el.removeAttribute("data-size");
  const len = route.length;
  if (len > 48) el.setAttribute("data-size", "xs");
  else if (len > 32) el.setAttribute("data-size", "sm");
}

// ---- Token display ----
function updateTokenDisplay() {
  const fSym = fromToken, tSym = toToken;
  setHTML("fromTokenIcon", iconForSymbol(fSym));
  setText("fromTokenSymbol", tokens[fSym].symbol);
  setHTML("toTokenIcon", iconForSymbol(tSym));
  setText("toTokenSymbol", tokens[tSym].symbol);
}

// ---- Token modal ----
function initTokenListClick() {
  const list = $("tokenList");
  if (!list || list.dataset.inited === "1") return;
  list.dataset.inited = "1";
  list.addEventListener("click", (e) => {
    // Handle .wei list remove button
    const removeBtn = e.target.closest('.wei-list-remove');
    if (removeBtn) {
      const listName = removeBtn.getAttribute('data-list');
      if (listName) {
        removeWeiList(listName);
        renderTokenList($('tokenSearchInput')?.value || '');
      }
      return;
    }
    const row = e.target.closest(".token-list-item");
    if (!row) return;
    const symbol = row.getAttribute("data-symbol");
    if (symbol) selectToken(symbol);
  });
}

function openTokenModal(side) {
  currentModal = side;
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
  renderTokenList('');
  $("tokenModal").classList.add('active');
  document.body.classList.add('modal-open');
  if (searchInput) searchInput.focus();
  // Batch-fetch all token balances via Multicall3 (single RPC)
  if (connectedAddress) fetchModalBalances();
}

function closeTokenModal() {
  $("tokenModal").classList.remove('active');
  document.body.classList.remove('modal-open');
  $("customTokenAddress").value = "";
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
}

const reQuoteDebounced = debounce(handleAmountChange, 600);

function selectToken(symbol) {
  if (currentModal === "from") {
    if (symbol === toToken) toToken = fromToken;
    fromToken = symbol;
  } else {
    if (symbol === fromToken) fromToken = toToken;
    toToken = symbol;
  }
  updateTokenDisplay();
  updateBalances();
  closeTokenModal();
  currentModal = null;
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

async function addCustomToken() {
  let address = $("customTokenAddress").value.trim();
  if (!ethers.isAddress(address)) { alert("Invalid address"); return; }
  address = ethers.getAddress(address);
  if (address === ZERO_ADDRESS) { alert("Zero address is not a valid ERC-20"); return; }

  try {
    const rpc = provider || new ethers.JsonRpcProvider("https://eth.llamarpc.com");
    try {
      const code = await rpc.getCode(address);
      if (!code || code === "0x") { alert("That address has no contract code on Ethereum."); return; }
    } catch (_) {}

    const erc20 = new ethers.Contract(address, [
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
    ], rpc);
    const [rawSymbol, rawDecimals] = await Promise.all([erc20.symbol(), erc20.decimals()]);

    const symbol = String(rawSymbol || "").trim().slice(0, 24) || "TKN";
    const rawDec = Number(rawDecimals);
    const decimals = Number.isInteger(rawDec) && rawDec >= 0 && rawDec <= 36 ? rawDec : 18;

    const existing = tokens[symbol];
    if (existing && existing.address.toLowerCase() !== address.toLowerCase()) {
      alert(`A different token with symbol ${symbol} is already listed.`);
      return;
    }

    tokens[symbol] = { address, symbol, decimals };
    saveCustomTokens();
    selectToken(symbol);
  } catch (e) {
    console.error("Error adding token:", e);
    alert("Failed to add token. Ensure it's a valid ERC-20 on Ethereum.");
  }
}

// ---- Keyboard shortcuts ----
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeTokenModal();
    closeWalletModal();
  }
});

// ---- Init ----
document.addEventListener("DOMContentLoaded", () => {
  loadWeiLists();
  updateTokenDisplay();
  initTokenListClick();
  initTokenSearch();
  const fromEl = $("fromAmount");
  if (fromEl) fromEl.addEventListener("input", debounce(handleAmountChange, 400));
});

// Swap button click
$("swapBtn").addEventListener("click", executeSwap);

// ---- Auto-reconnect ----
window.addEventListener("load", async () => {
  try {
    const savedWallet = localStorage.getItem('zswap_wallet');
    if (savedWallet) {
      // Wait a moment for EIP-6963 providers to announce
      await new Promise(r => setTimeout(r, 300));
      window.dispatchEvent(new Event('eip6963:requestProvider'));
      await new Promise(r => setTimeout(r, 200));
      await connectWithWallet(savedWallet);
    }
  } catch (e) {
    console.error("Auto-reconnect failed:", e);
  }
});

</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"8510b592df8f4a69b87bbf8e840f200c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
